# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Home.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import requests
import base64
import hashlib
import json
import sys
import os
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# Add ABE module path
abe_module_path = os.path.join(os.path.dirname(__file__), '..', 'AttributeAuthority')
if abe_module_path not in sys.path:
    sys.path.append(abe_module_path)

try:
    from ABE_Module import ABECore
    abe_available = True
    print("ABE module loaded successfully")
except ImportError as e:
    print(f"Warning: ABE module not available: {e}")
    abe_available = False

# Enhanced ABE client that works with both AA server and EHR server
class EnhancedABEClient:
    def __init__(self):
        self.aa_server_url = "http://localhost:5001"
        self.ehr_server_url = "http://localhost:5000"
        self.token = None
        self.user_info = None
        self.abe_core = None
        
        if abe_available:
            try:
                self.abe_core = ABECore()
                print("ABE Core initialized")
            except Exception as e:
                print(f"ABE Core init error: {e}")
    
    def set_auth_token(self, token, user_info):
        """Set authentication token and user info"""
        self.token = token
        self.user_info = user_info
        print(f"ABE Client: Token set for user {user_info.get('username', 'unknown')}")
    
    def get_headers(self):
        """Get headers with authentication token"""
        if self.token:
            return {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.token}"
            }
        return {"Content-Type": "application/json"}
    
    def register_current_user_with_aa(self):
        """Register current user with AA server via EHR server"""
        try:
            if not self.token or not self.user_info:
                return False, "Missing authentication token or user info"
            
            print(f"üîß Registering user with AA server...")
            
            response = requests.post(
                f"{self.ehr_server_url}/api/abe/register-current-user",
                headers=self.get_headers(),
                timeout=30
            )
            
            print(f"üì° AA registration response: {response.status_code}")
            print(f"üì° Response: {response.text}")
            
            if response.status_code == 200:
                result = response.json()
                print(f"‚úÖ User registered with attributes: {result.get('attributes', [])}")
                return True, result
            else:
                error_msg = response.json().get("message", f"HTTP {response.status_code}")
                return False, error_msg
                
        except Exception as e:
            return False, f"Error: {str(e)}"
    
    def encrypt_aes_key_for_patient(self, aes_key, access_policy):
        """Encrypt AES key with access policy for patient data"""
        try:
            data = {
                "aes_key": aes_key,
                "policy": access_policy
            }
            
            print(f"üîê Encrypting AES key with policy: {access_policy}")
            
            response = requests.post(
                f"{self.ehr_server_url}/api/abe/encrypt-aes-key",
                json=data,
                headers=self.get_headers(),
                timeout=30
            )
            
            print(f"üì° EHR server response: {response.status_code}")
            
            if response.status_code == 200:
                result = response.json()
                return True, result.get("encrypted_key")
            else:
                error_msg = response.json().get("message", f"HTTP {response.status_code}")
                return False, error_msg
                
        except Exception as e:
            return False, f"Error: {str(e)}"
    
    def decrypt_aes_key_for_patient(self, encrypted_aes_key, user_id):
        """Decrypt AES key for patient data access"""
        try:
            data = {
                "encrypted_key": encrypted_aes_key,
                "user_id": user_id
            }
            
            print(f"üîì Decrypting AES key for user: {user_id}")
            
            response = requests.post(
                f"{self.ehr_server_url}/api/abe/decrypt-aes-key",
                json=data,
                headers=self.get_headers(),
                timeout=30
            )
            
            print(f"üì° Decrypt response: {response.status_code}")
            print(f"üì° Response: {response.text}")
            
            if response.status_code == 200:
                result = response.json()
                return True, result.get("decrypted_key")
            else:
                error_msg = response.json().get("message", f"HTTP {response.status_code}")
                return False, error_msg
                
        except Exception as e:
            return False, f"Error: {str(e)}"
    
    def decrypt_patient_data(self, patient_data):
        """Decrypt patient data for viewing"""
        try:
            if not self.token or not self.user_info:
                return False, "Missing authentication token or user info"
            
            user_id = self.user_info.get('user_id') or self.user_info.get('id')
            encrypted_aes_key = patient_data.get('encrypted_aes_key')
            
            if not encrypted_aes_key:
                return False, "No encrypted AES key found"
            
            print(f"üîì Attempting to decrypt AES key for user: {user_id}")
            
            # Decrypt the AES key using ABE
            success, aes_key = self.decrypt_aes_key_for_patient(encrypted_aes_key, user_id)
            
            if not success:
                return False, f"Failed to decrypt AES key: {aes_key}"
            
            if aes_key:
                # Now decrypt the patient data fields
                decrypted_data = self.decrypt_patient_fields(patient_data, aes_key)
                return True, decrypted_data
            else:
                return False, "Failed to get decrypted AES key"
                
        except Exception as e:
            return False, f"Error: {str(e)}"

    def decrypt_patient_fields(self, patient_data, aes_key):
        """Decrypt individual patient data fields"""
        try:
            decrypted_data = patient_data.copy()
            
            # List of encrypted fields
            encrypted_fields = [
                'NgaySinh', 'DiaChi', 'ThongTinLienLac', 'TienSuBenh',
                'Tuoi', 'CanNang', 'ChieuCao', 'NhomMau', 'DonThuoc',
                'DiUng', 'ChiTietBenh', 'GioiTinh'
            ]
            
            for field in encrypted_fields:
                if field in patient_data and patient_data[field]:
                    try:
                        # Decrypt field using the helper method
                        encrypted_value = patient_data[field]
                        decrypted_value = self.aes_decrypt(encrypted_value, aes_key)
                        decrypted_data[field] = decrypted_value
                    except Exception as field_error:
                        print(f"‚ùå Error decrypting field {field}: {field_error}")
                        decrypted_data[field] = f"[L·ªói gi·∫£i m√£: {field}]"
            
            return decrypted_data
            
        except Exception as e:
            print(f"‚ùå Error in decrypt_patient_fields: {e}")
            return patient_data

    def aes_decrypt(self, encrypted_text, key):
        """Decrypt AES encrypted text using AES-256-GCM (matching AddPatient.py encryption)"""
        try:
            # Handle mock key for testing
            if key == 'bW9ja19kZWNyeXB0ZWRfYWVzX2tleQ==':
                return f"[MOCK DECRYPTED: {encrypted_text[:50]}...]"
            
            # Handle different key formats and ensure correct length
            if isinstance(key, str):
                # Remove any whitespace
                key = key.strip()
                
                # If key is hex encoded (most common from server)
                if len(key) == 64 and all(c in '0123456789abcdefABCDEF' for c in key):
                    # This is a 64-character hex string = 32 bytes
                    aes_key = bytes.fromhex(key)
                    print(f"üîë Using hex key: {key[:16]}... (length: {len(aes_key)} bytes)")
                else:
                    # If key is too long, truncate to 64 hex chars
                    if len(key) > 64:
                        hex_key = key[:64]
                        aes_key = bytes.fromhex(hex_key)
                        print(f"üîë Truncated hex key to 32 bytes")
                    else:
                        # Hash the key to get consistent 32 bytes
                        aes_key = hashlib.sha256(key.encode('utf-8')).digest()
                        print(f"üîë Hashed key to 32 bytes")
            else:
                aes_key = key[:32] if len(key) > 32 else key.ljust(32, b'\x00')
            
            print(f"üîë Final AES key length: {len(aes_key)} bytes")
            
            # FIXED: Proper AES-GCM decryption (matching AddPatient.py encryption)
            try:
                # Try GCM format: base64(nonce[12] + tag[16] + encrypted_data)
                combined = base64.b64decode(encrypted_text)
                
                # Check if this looks like GCM format (at least 28 bytes for nonce+tag)
                if len(combined) >= 28:
                    nonce = combined[:12]  # GCM nonce is 12 bytes
                    tag = combined[12:28]  # GCM tag is 16 bytes
                    encrypted_data = combined[28:]
                    
                    print(f"üîê Attempting GCM decryption: nonce={len(nonce)}, tag={len(tag)}, data={len(encrypted_data)}")
                    
                    # Decrypt using GCM (this should match AddPatient.py encryption)
                    cipher = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)
                    decrypted = cipher.decrypt_and_verify(encrypted_data, tag)
                    
                    result = decrypted.decode('utf-8')
                    print(f"‚úÖ GCM decryption successful: {result[:50]}...")
                    return result
                else:
                    raise Exception("Data too short for GCM format")
                    
            except Exception as gcm_error:
                print(f"‚ùå GCM decryption failed: {gcm_error}")
                
                # Fallback to CBC for legacy data only
                print("‚ö†Ô∏è Falling back to CBC mode for legacy data...")
                try:
                    # Try different CBC formats
                    if ':' in encrypted_text:
                        # Format: iv_hex:encrypted_hex
                        iv_hex, encrypted_hex = encrypted_text.split(':', 1)
                        iv = bytes.fromhex(iv_hex)
                        encrypted_data = bytes.fromhex(encrypted_hex)
                    else:
                        # Format: base64(iv + encrypted_data)
                        combined = base64.b64decode(encrypted_text)
                        if len(combined) < 16:
                            raise Exception("Data too short for CBC")
                        iv = combined[:16]
                        encrypted_data = combined[16:]
                    
                    # Create cipher and decrypt
                    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
                    decrypted = unpad(cipher.decrypt(encrypted_data), AES.block_size)
                    
                    result = decrypted.decode('utf-8')
                    print(f"‚úÖ CBC fallback successful: {result[:50]}...")
                    return result
                    
                except Exception as cbc_error:
                    print(f"‚ùå CBC fallback also failed: {cbc_error}")
                    print(f"‚ùå Key: {key[:32] if isinstance(key, str) else 'bytes'}...")
                    print(f"‚ùå Encrypted text: {encrypted_text[:100]}...")
                    return "[L·ªói gi·∫£i m√£ - D·ªØ li·ªáu c√≥ th·ªÉ b·ªã h·ªèng]"
            
        except Exception as e:
            print(f"‚ùå General AES decrypt error: {e}")
            print(f"‚ùå Key: {key[:32] if isinstance(key, str) else 'bytes'}...")
            print(f"‚ùå Encrypted text: {encrypted_text[:100]}...")
            return "[L·ªói gi·∫£i m√£]"

    def aes_encrypt_gcm(self, plaintext, key):
        """Encrypt using AES-256-GCM (secure mode)"""
        try:
            # Ensure 32-byte key
            if isinstance(key, str):
                if len(key) == 64:  # hex string
                    aes_key = bytes.fromhex(key)
                else:
                    aes_key = hashlib.sha256(key.encode('utf-8')).digest()
            else:
                aes_key = key[:32] if len(key) > 32 else key.ljust(32, b'\x00')
            
            # Generate random nonce (12 bytes for GCM)
            nonce = secrets.token_bytes(12)
            
            # Create cipher and encrypt
            cipher = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)
            encrypted_data, tag = cipher.encrypt_and_digest(plaintext.encode('utf-8'))
            
            # Combine nonce + tag + encrypted_data and encode as base64
            combined = nonce + tag + encrypted_data
            return base64.b64encode(combined).decode('utf-8')
            
        except Exception as e:
            print(f"‚ùå AES-GCM encrypt error: {e}")
            raise

    def check_user_access(self, policy_expression, user_attributes):
        """Check if user has access based on policy (simple implementation)"""
        try:
            # Simple policy check - for ADMIN users, always allow
            if 'ROLE:ADMIN' in user_attributes:
                return True
            
            # For other users, check if any of their attributes match the policy
            for attr in user_attributes:
                if attr in policy_expression:
                    return True
            
            return False
        except Exception as e:
            print(f"Error checking access: {e}")
            return False

# Global ABE client
abe_client = EnhancedABEClient()

class Ui_mainWindow(object):
    def __init__(self):
        self.token = None
        self.user_info = None
        self.user_id = None
        self.user_role = None
        self.user_department = None
        self.user_attributes = []

    def setupUi(self, mainWindow):
        mainWindow.setObjectName("mainWindow")
        mainWindow.resize(703, 600)
        self.centralwidget = QtWidgets.QWidget(mainWindow)
        self.centralwidget.setObjectName("centralwidget")
        
        # ADD: User info display at the top
        self.lbUserInfo = QtWidgets.QLabel(self.centralwidget)
        self.lbUserInfo.setGeometry(QtCore.QRect(10, 10, 470, 25))
        self.lbUserInfo.setObjectName("lbUserInfo")
        self.lbUserInfo.setStyleSheet("QLabel { color: blue; font-weight: bold; font-size: 12px; }")
        
        # ADD: User attributes display
        self.lbUserAttributes = QtWidgets.QLabel(self.centralwidget)
        self.lbUserAttributes.setGeometry(QtCore.QRect(10, 35, 470, 20))
        self.lbUserAttributes.setObjectName("lbUserAttributes")
        self.lbUserAttributes.setStyleSheet("QLabel { color: green; font-size: 10px; }")
        
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setGeometry(QtCore.QRect(10, 80, 681, 471))
        self.groupBox.setObjectName("groupBox")
        self.label = QtWidgets.QLabel(self.groupBox)
        self.label.setGeometry(QtCore.QRect(10, 50, 221, 17))
        self.label.setObjectName("label")
        self.tbIDBenhNhan = QtWidgets.QLineEdit(self.groupBox)
        self.tbIDBenhNhan.setGeometry(QtCore.QRect(240, 50, 113, 25))
        self.tbIDBenhNhan.setObjectName("tbIDBenhNhan")
        self.btXemThongTinBenhNhan = QtWidgets.QPushButton(self.groupBox)
        self.btXemThongTinBenhNhan.setGeometry(QtCore.QRect(390, 50, 251, 25))
        self.btXemThongTinBenhNhan.setObjectName("btXemThongTinBenhNhan")
        self.tbHienThiDanhSachBenhNhan = QtWidgets.QTextBrowser(self.groupBox)
        self.tbHienThiDanhSachBenhNhan.setGeometry(QtCore.QRect(50, 190, 301, 261))
        self.tbHienThiDanhSachBenhNhan.setObjectName("tbHienThiDanhSachBenhNhan")
        # self.btLayDanhSachBenhNhan = QtWidgets.QPushButton(self.groupBox)
        # self.btLayDanhSachBenhNhan.setGeometry(QtCore.QRect(380, 190, 241, 25))
        # self.btLayDanhSachBenhNhan.setObjectName("btLayDanhSachBenhNhan")
        self.label_2 = QtWidgets.QLabel(self.groupBox)
        self.label_2.setGeometry(QtCore.QRect(50, 150, 301, 17))
        self.label_2.setObjectName("label_2")
        self.btDangXuat = QtWidgets.QPushButton(self.centralwidget)
        self.btDangXuat.setGeometry(QtCore.QRect(600, 10, 89, 25))
        self.btDangXuat.setObjectName("btDangXuat")
        self.btThemEHR = QtWidgets.QPushButton(self.centralwidget)
        self.btThemEHR.setGeometry(QtCore.QRect(490, 10, 89, 25))
        self.btThemEHR.setObjectName("btThemEHR")
        mainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(mainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 703, 22))
        self.menubar.setObjectName("menubar")
        mainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(mainWindow)
        self.statusbar.setObjectName("statusbar")
        mainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(mainWindow)
        QtCore.QMetaObject.connectSlotsByName(mainWindow)
        
        # Connect buttons
        self.btThemEHR.clicked.connect(self.openAddPatient)
        # self.btLayDanhSachBenhNhan.clicked.connect(self.getPatientsList)
        self.btXemThongTinBenhNhan.clicked.connect(self.getPatientDetail)
        self.btDangXuat.clicked.connect(self.logout)

    def retranslateUi(self, mainWindow):
        _translate = QtCore.QCoreApplication.translate
        mainWindow.setWindowTitle(_translate("mainWindow", "Tra c·ª©u h·ªì s∆° b·ªánh nh√¢n"))
        self.groupBox.setTitle(_translate("mainWindow", "Tra c·ª©u"))
        self.label.setText(_translate("mainWindow", "Nh·∫≠p ID b·ªánh nh√¢n c·∫ßn tra c·ª©u"))
        self.btXemThongTinBenhNhan.setText(_translate("mainWindow", "Xem th√¥ng tin chi ti·∫øt b·ªánh nh√¢n"))
        # self.btLayDanhSachBenhNhan.setText(_translate("mainWindow", "L·∫•y danh s√°ch b·ªánh nh√¢n c√≥ h·ªì s∆°"))
        self.label_2.setText(_translate("mainWindow", "Hi·ªÉn th·ªã c√°c b·ªánh nh√¢n c√≥ h·ªì s∆° y t·∫ø ƒëi·ªán t·ª≠"))
        self.btDangXuat.setText(_translate("mainWindow", "ƒêƒÉng Xu·∫•t"))
        self.btThemEHR.setText(_translate("mainWindow", "Th√™m EHR"))
        
        # Initialize user info labels (will be updated when user logs in)
        self.lbUserInfo.setText(_translate("mainWindow", "Ch∆∞a ƒëƒÉng nh·∫≠p"))
        self.lbUserAttributes.setText(_translate("mainWindow", ""))

    def setUserInfo(self, token, user_info):
        """Set user information and initialize ABE"""
        print(f"Home received token: {token[:20] if token else 'None'}...")
        print(f"Home received user_info: {user_info}")
        
        self.token = token
        self.user_info = user_info
        self.user_id = user_info.get('user_id') or user_info.get('id')
        self.user_role = user_info.get('role')
        self.user_department = user_info.get('department')
        
        # Build user attributes for display
        self.user_attributes = [f"ROLE:{self.user_role}"]
        if self.user_department:
            self.user_attributes.append(f"DEPT:{self.user_department}")
        
        # UPDATE: Display user info in the UI
        self.updateUserInfoDisplay()
        
        # Set up ABE client
        abe_client.set_auth_token(token, user_info)
        
        # Register user with AA server
        self.register_with_aa()

    def updateUserInfoDisplay(self):
        """Update the user info display labels"""
        try:
            if self.user_info:
                username = self.user_info.get('username', 'Unknown')
                fullname = self.user_info.get('fullName', '')
                role = self.user_role or 'Unknown'
                department = self.user_department or 'None'
                
                # Format user info text
                if fullname:
                    user_text = f"üë§ Ng∆∞·ªùi d√πng: {fullname} (@{username}) - Vai tr√≤: {role}"
                else:
                    user_text = f"üë§ Ng∆∞·ªùi d√πng: {username} - Vai tr√≤: {role}"
                
                if department and department.upper() != 'NONE':
                    user_text += f" - Khoa: {department}"
                
                # Format attributes text
                attributes_text = f"üîë Quy·ªÅn truy c·∫≠p: {', '.join(self.user_attributes)}"
                
                # Update labels
                self.lbUserInfo.setText(user_text)
                self.lbUserAttributes.setText(attributes_text)
                
                # Set different colors based on role
                if role == 'ADMIN':
                    self.lbUserInfo.setStyleSheet("QLabel { color: red; font-weight: bold; font-size: 12px; }")
                elif role == 'DOCTOR':
                    self.lbUserInfo.setStyleSheet("QLabel { color: blue; font-weight: bold; font-size: 12px; }")
                elif role == 'NURSE':
                    self.lbUserInfo.setStyleSheet("QLabel { color: green; font-weight: bold; font-size: 12px; }")
                else:
                    self.lbUserInfo.setStyleSheet("QLabel { color: purple; font-weight: bold; font-size: 12px; }")
                    
            else:
                self.lbUserInfo.setText("Ch∆∞a ƒëƒÉng nh·∫≠p")
                self.lbUserAttributes.setText("")
                
        except Exception as e:
            print(f"Error updating user info display: {e}")
            self.lbUserInfo.setText("L·ªói hi·ªÉn th·ªã th√¥ng tin ng∆∞·ªùi d√πng")
            self.lbUserAttributes.setText("")

    def register_with_aa(self):
        """Register current user with AA server"""
        try:
            print("üîß Registering user with AA server...")
            success, result = abe_client.register_current_user_with_aa()
            
            if success:
                print(f"‚úÖ User registered with AA server: {result}")
            else:
                print(f"‚ö†Ô∏è AA registration warning: {result}")
                
        except Exception as e:
            print(f"‚ùå Error registering with AA: {e}")

    def getPatientDetail(self):
        """Get and decrypt patient details"""
        try:
            patient_id = self.tbIDBenhNhan.text().strip()
            
            if not patient_id:
                QtWidgets.QMessageBox.warning(
                    None, 
                    "L·ªói", 
                    "Vui l√≤ng nh·∫≠p ID b·ªánh nh√¢n!"
                )
                return
            
            print(f"üîç Getting patient details for ID: {patient_id}")
            
            # Get encrypted patient data from server
            headers = {
                "Authorization": f"Bearer {self.token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(
                f"http://localhost:5000/api/patients/{patient_id}",
                headers=headers,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                patient_data = result.get('patient', result)  # Handle both response formats
                
                # Attempt to decrypt the patient data
                print(f"üîì Attempting to decrypt patient data...")
                success, decrypted_data = abe_client.decrypt_patient_data(patient_data)
                
                if success:
                    # Show decrypted data
                    self.display_patient_data(decrypted_data, decrypted=True)
                    print(f"‚úÖ Successfully decrypted patient data!")
                else:
                    # Show access denied message
                    QtWidgets.QMessageBox.warning(
                        None, 
                        "Truy c·∫≠p b·ªã t·ª´ ch·ªëi", 
                        f"Kh√¥ng th·ªÉ gi·∫£i m√£ d·ªØ li·ªáu b·ªánh nh√¢n: {decrypted_data}\n\n"
                        f"B·∫°n c√≥ th·ªÉ kh√¥ng c√≥ quy·ªÅn truy c·∫≠p d·ªØ li·ªáu n√†y."
                    )
                    
                    # Still show encrypted data (for debugging)
                    self.display_patient_data(patient_data, decrypted=False)
            else:
                error_data = response.json() if response.headers.get('content-type', '').startswith('application/json') else {}
                error_message = error_data.get('message', f'HTTP {response.status_code}')
                QtWidgets.QMessageBox.warning(
                    None, 
                    "L·ªói", 
                    f"Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu b·ªánh nh√¢n: {error_message}"
                )
                
        except Exception as e:
            print(f"‚ùå Error in getPatientDetail: {e}")
            QtWidgets.QMessageBox.critical(
                None, 
                "L·ªói", 
                f"L·ªói h·ªá th·ªëng: {str(e)}"
            )

    def display_patient_data(self, patient_data, decrypted=False):
        """Display patient data (decrypted or encrypted)"""
        try:
            status = "üîì ƒê√É GI·∫¢I M√É" if decrypted else "üîí M√É H√ìA"
            
            display_text = f"TH√îNG TIN B·ªÜNH NH√ÇN ({status})\n\n"
            display_text += f"ID: {patient_data.get('ID_BenhNhan', 'N/A')}\n"
            display_text += f"H·ªç t√™n: {patient_data.get('HoTen', 'N/A')}\n"
            display_text += f"Ng√†y sinh: {patient_data.get('NgaySinh', 'N/A')}\n"
            display_text += f"Gi·ªõi t√≠nh: {patient_data.get('GioiTinh', 'N/A')}\n"
            display_text += f"Tu·ªïi: {patient_data.get('Tuoi', 'N/A')}\n"
            display_text += f"C√¢n n·∫∑ng: {patient_data.get('CanNang', 'N/A')} kg\n"
            display_text += f"Chi·ªÅu cao: {patient_data.get('ChieuCao', 'N/A')} cm\n"
            display_text += f"Nh√≥m m√°u: {patient_data.get('NhomMau', 'N/A')}\n"
            display_text += f"ƒê·ªãa ch·ªâ: {patient_data.get('DiaChi', 'N/A')}\n"
            display_text += f"Th√¥ng tin li√™n l·∫°c: {patient_data.get('ThongTinLienLac', 'N/A')}\n"
            display_text += f"Ti·ªÅn s·ª≠ b·ªánh: {patient_data.get('TienSuBenh', 'N/A')}\n"
            display_text += f"D·ªã ·ª©ng: {patient_data.get('DiUng', 'N/A')}\n"
            display_text += f"Chi ti·∫øt b·ªánh: {patient_data.get('ChiTietBenh', 'N/A')}\n"
            display_text += f"ƒê∆°n thu·ªëc: {patient_data.get('DonThuoc', 'N/A')}\n"
            
            if decrypted:
                display_text += f"\n‚úÖ Truy c·∫≠p th√†nh c√¥ng v·ªõi quy·ªÅn: {', '.join(self.user_attributes)}"
            else:
                display_text += f"\n‚ö†Ô∏è CH√ö √ù: D·ªØ li·ªáu ƒëang ƒë∆∞·ª£c m√£ h√≥a. B·∫°n c√≥ th·ªÉ kh√¥ng c√≥ quy·ªÅn gi·∫£i m√£.\n"
                display_text += f"Ch√≠nh s√°ch truy c·∫≠p: {patient_data.get('access_policy', 'N/A')}\n"
            
            # Show in the text browser
            self.tbHienThiDanhSachBenhNhan.setText(display_text)
            
        except Exception as e:
            print(f"‚ùå Error displaying patient data: {e}")

    def getPatientsList(self):
        """Get list of patients"""
        try:
            if not hasattr(self, 'token'):
                self.tbHienThiDanhSachBenhNhan.setText("L·ªói: Ch∆∞a ƒëƒÉng nh·∫≠p!")
                return
                
            headers = {"Authorization": f"Bearer {self.token}"}
            response = requests.get("http://localhost:5000/api/patients", headers=headers)
            
            if response.status_code == 200:
                patients = response.json()
                
                # Enhanced header with user info
                username = self.user_info.get('username', 'Unknown')
                fullname = self.user_info.get('fullName', '')
                display_name = fullname if fullname else username
                department = self.user_department if self.user_department else 'None'
                
                patient_list_text = f"üìã DANH S√ÅCH B·ªÜNH NH√ÇN\n"
                patient_list_text += f"üë§ Ng∆∞·ªùi d√πng: {display_name} ({self.user_role})\n"
                if department and department.upper() != 'NONE':
                    patient_list_text += f"üè• Khoa: {department}\n"
                patient_list_text += f"üîë Quy·ªÅn: {', '.join(self.user_attributes)}\n"
                patient_list_text += "=" * 50 + "\n\n"
                
                if not patients:
                    patient_list_text += "Kh√¥ng c√≥ b·ªánh nh√¢n n√†o trong h·ªá th·ªëng."
                else:
                    accessible_count = 0
                    for i, patient in enumerate(patients, 1):
                        patient_id = patient.get('ID_BenhNhan', 'N/A')
                        name = patient.get('HoTen', 'N/A')
                        policy = patient.get('access_policy', 'N/A')
                        
                        # Check if user can access this patient's detailed data
                        if self.user_role == 'ADMIN':
                            # Admin can see all patients
                            access_status = "üîì C√≥ quy·ªÅn truy c·∫≠p"
                            accessible_count += 1
                        else:
                            # Check access based on patient's policy
                            can_access = abe_client.check_user_access(policy, self.user_attributes)
                            if can_access:
                                access_status = "üîì C√≥ quy·ªÅn truy c·∫≠p"
                                accessible_count += 1
                            else:
                                access_status = "üîí Kh√¥ng c√≥ quy·ªÅn"
                        
                        patient_list_text += f"{i}. ID: {patient_id} - {name}\n"
                        patient_list_text += f"   üìã Ch√≠nh s√°ch: {policy}\n"
                        patient_list_text += f"   üîê Tr·∫°ng th√°i: {access_status}\n\n"
                    
                    patient_list_text += "=" * 50 + "\n"
                    patient_list_text += f"üìä T·ªïng c·ªông: {len(patients)} b·ªánh nh√¢n | C√≥ quy·ªÅn truy c·∫≠p: {accessible_count} b·ªánh nh√¢n"
                
                self.tbHienThiDanhSachBenhNhan.setText(patient_list_text)
                
            else:
                error_message = response.json().get('error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')
                self.tbHienThiDanhSachBenhNhan.setText(f"L·ªói: {error_message}")
                
        except Exception as e:
            self.tbHienThiDanhSachBenhNhan.setText(f"L·ªói khi l·∫•y danh s√°ch b·ªánh nh√¢n: {str(e)}")

    def openAddPatient(self):
        """Open Add Patient window"""
        try:
            print(f"Opening AddPatient with token: {self.token[:20] if self.token else 'None'}...")
            
            from AddPatient import Ui_MainWindow as AddPatientUI
            
            self.add_patient_window = QtWidgets.QMainWindow()
            self.add_patient_ui = AddPatientUI()
            self.add_patient_ui.setupUi(self.add_patient_window)
            
            if self.token and self.user_info:
                # Set user info first
                self.add_patient_ui.setUserInfo(self.token, self.user_info)
                
                # Set parent window reference for "Quay lai" button
                current_window = self.centralwidget.window()
                self.add_patient_ui.setParentWindow(current_window)
                
                # Show AddPatient window and hide current
                self.add_patient_window.show()
                current_window.hide()
            else:
                print("No token or user_info available!")
                self.tbHienThiDanhSachBenhNhan.setText("L·ªói: Thi·∫øu th√¥ng tin ƒëƒÉng nh·∫≠p!")
                
        except Exception as e:
            print(f"Error opening AddPatient: {str(e)}")
            self.tbHienThiDanhSachBenhNhan.setText(f"L·ªói m·ªü trang th√™m b·ªánh nh√¢n: {str(e)}")

    def logout(self):
        """Logout and return to login screen"""
        try:
            if hasattr(self, 'token') and self.token:
                headers = {"Authorization": f"Bearer {self.token}"}
                response = requests.post("http://localhost:5000/api/users/logout", headers=headers)
                
                if response.status_code == 200:
                    self.tbHienThiDanhSachBenhNhan.setText("ƒêƒÉng xu·∫•t th√†nh c√¥ng. Token ƒë√£ b·ªã v√¥ hi·ªáu h√≥a.")
                    self.token = None
                    self.user_info = None
            
            main_window = self.centralwidget.window()
            
            if hasattr(main_window, 'parent_login_window'):
                login_window = main_window.parent_login_window
                main_window.close()
                login_window.show()
            else:
                self.tbHienThiDanhSachBenhNhan.setText("ƒê√£ ƒëƒÉng xu·∫•t, nh∆∞ng kh√¥ng th·ªÉ quay l·∫°i trang ƒëƒÉng nh·∫≠p. Vui l√≤ng ƒë√≥ng ·ª©ng d·ª•ng v√† ƒëƒÉng nh·∫≠p l·∫°i.")
                
        except Exception as e:
            self.tbHienThiDanhSachBenhNhan.setText(f"L·ªói khi ƒëƒÉng xu·∫•t: {str(e)}")

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    mainWindow = QtWidgets.QMainWindow()
    ui = Ui_mainWindow()
    ui.setupUi(mainWindow)
    mainWindow.show()
    sys.exit(app.exec_())
